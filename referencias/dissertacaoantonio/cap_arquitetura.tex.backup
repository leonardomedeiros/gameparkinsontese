\chapter{Arcabouço para a Aquisição de Dados de Saúde Utilizando Jogos Eletrônicos} \label{cap:arquitetura}

Este capítulo apresenta o arcabouço que permite o desenvolvimento de jogos eletrônicos para a aquisição de dados de saúde. São apresentados os requisitos funcionais do arcabouço e, em seguida, é feita uma descrição detalhada da arquitetura do arcabouço, mostrando seus componentes e funcionalidades.

\section{Requisitos do Arcabouço}

Para possibilitar o desenvolvimento de jogos para captura de dados de saúde, um arcabouço deve permitir a aquisição e persistência dos dados obtidos a partir da interação do usuário com sensores. A grande quantidade de dados coletada deve ser gerenciada pelo arcabouço de monitoramento de saúde, apoio à decisão e processamento de informação clínica para suportar médicos em suas decisões e melhorar o entendimento da dinâmica de doenças. O conhecimento médico é frequentemente atualizado e reavaliado para incluir a identificação de novos fatores de risco e novas evidências de estudos clínicos. Os desafios enfrentados atualmente são: incorporar em sistemas de saúde pessoais o conhecimento mais recente e baseado em evidências; e transformar a informação coletada em conhecimento para suportar o processo de tomada de decisão. A tecnologia pode ter um papel fundamental ao focar em uma abordagem baseada em conhecimento para integrar dados passados e atuais de cada indivíduo, junto com evidências estatísticas~\cite{Tartarisco20121296}.

Outro requisito do arcabouço é permitir que a coleta dos dados seja realizada de forma harmoniosa e imperceptível para o indivíduo, embutida no enredo do próprio jogo no qual é utilizado. Outras informações relevantes, como idade, gênero e medidas antropométricas, como peso e altura, podem ser obtidas em uma fase posterior, com o conhecimento do usuário, quando se fizer uso dos dados de saúde coletados pelo arcabouço.

\section{Arquitetura}

Na Figura~\ref{img:arquitetura}, apresenta-se uma visão geral da arquitetura da solução, que é constituída por quatro componentes: \emph{Web Service}, \emph{Gerenciador de Dados}, \emph{Analisador de Dados} e o \emph{Banco de Dados}. A estrutura estática do arcabouço pode ser vista no diagrama de classes, na Figura~\ref{img:classd}. Na Figura~\ref{img:arquitetura_an}, apresenta-se como a transferência de dados se dá dentro do arcabouço a partir das classes mostradas no diagrama de classes.

O processo se inicia com a aquisição dos dados dos sensores (1), que podem ser enviados para o \emph{webservice} e processados pela classe \texttt{ReadingResource} ou enviados por arquivos e processados pela classe \texttt{FileManager}, acessada através do \texttt{DataManager}. O \texttt{ReadingResource} envia os dados recebidos para o \texttt{DatabaseManager} (2), também acessado através do \texttt{DataManager}, para armazená-los no \emph{banco de dados}. A partir daí, os dados podem ou não ser filtrados através do \texttt{FilterModule} pelas classes de filtro que implementam a interface \texttt{IFilter}, e depois enviados para o \texttt{DataAnalyzer} (3). No \texttt{DataAnalyzer}, os dados estão prontos para serem processados pelas classes de análise que implementam a interface \texttt{IAnalyzer}. O \texttt{RuleManager} utiliza o \texttt{FileManager} para ler as regras de um arquivo (4) e as transfere para o \texttt{DataAnalyzer} (5), assim, os dados podem ser interpretados. O \texttt{DataAnalyzer} pode também enviar os dados para o \texttt{WriterModule} (6), que os escreverá em arquivo para visualização em outros programas, ou utilização em métodos de aprendizado de máquina, por exemplo.

\begin{figure}[!htb]
     \centering
     \includegraphics[width=1\textwidth]{arquitetura_alto_nivel.pdf}
     \caption{Transferência de Dados Dentro do Arcabouço}
     \label{img:arquitetura_an}
\end{figure}

O envio dos dados dos usuários coletados com os dispositivos é feito através de uma requisição POST para o \textit{web service}. Os dados devem ser coletados durante uma sessão completa do jogo, que dura de alguns segundos a alguns minutos, para depois serem estruturados e enviados para o \textit{web service}. O formato aceito pelas operações é o JSON (JavaScript Object Notation). Na Tabela~\ref{tab:operations}, ilustram-se as operações disponibilizadas pelo \textit{web service} e um exemplo de como os dados devem ser estruturados para cada operação.

\begin{figure}[!htb]
     \centering
     \includegraphics[width=1\textwidth]{arquitetura.pdf}
     \caption{Arquitetura do Arcabouço}
     \label{img:arquitetura}
\end{figure}

\begin{figure}[!htb]
     \centering
     \includegraphics[width=1\textwidth]{class_diagram.png}
     \caption{Diagrama de Classes do Arcabouço}
     \label{img:classd}
\end{figure}

\begin{table} 
\centering 
\caption{Operações disponibilizadas pelo \textit{web service}}
\begin{center}
    \begin{tabular}{ | l | c | l | }
        \hline
        Operação & Método & Exemplo \\ \hline
        cadastrarUsuario & POST & 
		\begin{minipage}{7cm}\begin{verbatim}
		
		{"id":2,"nome":"Ana",
		"masculino":false,
		"nascimento":"2012-11-28"}
		
		\end{verbatim}\end{minipage} \\ \hline
        obterToken & GET & - \\ \hline
        enviarDados & POST & 
		\begin{minipage}{7.5cm}\begin{verbatim}

		{"leitura":[{"id":0, 
		"idUsuario":1, "x":2.9097333, 
		"y":6.770132, "z":2.0355952, 
		"timestamp":1336134935706}, 
		{"id":0, "idUsuario":1, 
		"x":4.5565815, "y":4.9461093, 
		"z":1.4911331, 
		"timestamp":1336134935706}]}
		
		\end{verbatim}\end{minipage} \\ \hline
    \end{tabular}
\end{center}
\label{tab:operations}
\end{table}

\subsection{Módulo Gerenciador de Dados} \label{sec:ger_dados}

O \emph{Gerenciador de Dados} possui submódulos responsáveis por fazer leitura, separação e filtragem dos dados, além do gerenciamento destes no Banco de Dados e escrita dos resultados disponibilizados pelo \emph{Analisador de Dados}. A classe \texttt{DataManager} implementa as funcionalidades do \emph{Gerenciador de Dados}, referenciando os quatro módulos, \emph{Gerenciador de Arquivos}, \emph{Módulo de Escrita}, \emph{Módulo de Filtragem} e \emph{Gerenciador do Banco de Dados}, que são explicados nas subseções a seguir. A classe \texttt{DataManager} possui um construtor \texttt{DataManager(DatabaseManager, FileManager, WriterModule, FilterModule)}, que recebe como parâmetros os quatro módulos. Dessa forma, é possível aumentar a funcionalidade de cada um dos módulos estendendo suas respectivas classes por herança e adicionando a elas novos métodos. A classe \texttt{MovementDataFileManager}, tratada mais adiante, é um exemplo de extensão do \texttt{FileManager}.

O \emph{webservice}, implementado utilizando a biblioteca Jersey\footnote{Disponível em: http://jersey.java.net/}, envia as requisições para serem processadas pela classe \texttt{ReadingResource}, que é um \textit{web resource}, mapeado com anotações JAX-RS (Java API for RESTful Web Services). Esta classe possui dois métodos, o \texttt{get()} trata requisições \emph{GET}, retornando o identificador do último conjunto de leituras para controle do armazenamento no banco de dados; e o método \texttt{post(List<Reading> readings)} processa os dados das leituras enviados através de requisições \emph{POST}, e convertidos de JSON para objetos Java pela biblioteca Jersey. A classe \texttt{ReadingResource} está acoplada à classe \texttt{DataManager} e, através dela, tem acesso ao \emph{Gerenciador do Banco de Dados}. O \emph{webservice} pode ser instalado em qualquer \textit{web container}, como o Apache Tomcat\footnote{Disponível em: http://tomcat.apache.org/} e o GlassFish\footnote{Disponível em: http://glassfish.java.net/}.

\subsubsection{Gerenciador de Arquivos}

A classe \texttt{FileManager} implementa o módulo \emph{Gerenciador de Arquivos}, e processa as operações de abertura de arquivos de dados delegadas pelo \emph{Gerenciador de Dados}. Esse módulo processa os dados recebidos, armazenando-os em dados estruturados para serem processado posteriormente pelo \emph{Analisador de Dados}. O dado estruturado aceito pelo \emph{Analisador de Dados} é composto por um rótulo identificador do dado, uma marca de tempo com precisão de milissegundos, e coordenadas x, y e z, cujo significado depende do tipo de sensor que as gera.

Os métodos da classe \texttt{FileManager} são:
\begin{enumerate}
	\item \texttt{getLabelData(List<Reading> data, String... labels)} filtra os dados da lista de leituras \texttt{data}, retornando uma nova lista \texttt{List<Reading>} contendo apenas os dados com os rótulos definidos em \texttt{labels}.
	\item \texttt{getDataFromFile(String path, String separator, boolean hasHeader)} lê os dados de um arquivo localizado no caminho \texttt{path}, cujos dados estão separados pelo separador \texttt{separator} e definidos linha a linha. O parâmetro \texttt{hasHeader} indica se o método deve procurar por uma linha de cabeçalho na primeira linha do arquivo. Retorna uma \texttt{List<Reading>} com os dados.
	\item \label{getdatamethod} \texttt{getDataFromFile(String path, String separator, boolean hasHeader, String... labels)} estende a funcionalidade do método anterior, retornando uma \texttt{List<Reading>} com os dados que possuem os rótulos definidos em \texttt{labels}.
	\item \texttt{getMultipleData(String path, String separator, boolean hasHeader, String... labels)} possui a mesma função que o método~\ref{getdatamethod}, mas, diferente deste, retorna um \texttt{Map<String, List<Reading>>} onde cada chave do mapa é um rótulo e indexa uma lista de eventos identificados pelo rótulo.
	\item \texttt{getBufferedReader(String path)} retorna um \texttt{BufferedReader} para manipular o arquivo cujo caminho é especificado dem \texttt{path}.
\end{enumerate}

A classe \texttt{MovementDataFileManager} estende as funcionalidades do \texttt{FileManager}, adicionando um método para leitura de eventos oriundos de jogos. Os eventos marcam o início ou fim de um momento específico do jogo no qual o jogador estará executando um movimento que será enviado para análise.

\subsubsection{Módulo de Escrita}

O \emph{Módulo de Escrita} é implementado pela classe \texttt{WriterModule}, e é responsável pela saída dos dados processados pelo \emph{Analisador de Dados}. Os dados podem ser estruturados para serem mostrados em um programa de plotagem de gráficos, como o GNUPlot\footnote{Disponível em: http://www.gnuplot.info/}, ou para servirem como entrada para mecanismos de aprendizado de máquina. Os dados são escritos em CSV (\textit{Comma-separated Values}) ou em qualquer outro formato definido pelo usuário do arcabouço. O módulo de escrita também suporta a escrita de arquivos ARFF, para serem processados pelo Weka\footnote{Disponível em: http://www.cs.waikato.ac.nz/ml/weka/}. O \emph{Módulo de Escrita} é extensível para permitir a geração de um formato de arquivo específico. A criação de um novo arquivo de dados é feita através da extensão da classe \texttt{WriterImpl} pela classe que se está criando.

A interface \texttt{IWriter} define três métodos para manipular arquivos de dados:

\begin{enumerate}
	\item \label{formatlinemethod} \texttt{formatLine(Object... items)} formata os itens \texttt{items} adicionando separadores ou qualquer outra formatação adicional definida na classe específica de escrita que implementa \texttt{IWriter} ou estende \texttt{WriterImpl}.
	\item \texttt{writeLine(Object... items)} escreve uma nova linha no arquivo, seguindo a formatação definida pelo método~\ref{formatlinemethod}.
	\item \texttt{save()} fecha a \textit{stream} de escrita dedicada ao arquivo e salva o arquivo em disco.
\end{enumerate}

A classe \texttt{WriterImpl} implementa os métodos comuns a todas as classes de escrita, definidos pela interface \texttt{IWriter}, fornecendo um método adicional para incluir separadores entre os elementos de uma linha. Para definir um comportamento diferente daquele implementado por \texttt{WriterImpl}, deve-se implementar diretamente a interface \texttt{IWriter}.

\subsubsection{Módulo de Filtragem}

O \emph{Módulo de Filtragem} faz o pré-processamento dos dados, realizando a filtragem. A classe \texttt{FilterModule} implementa as funcionalidades do \emph{Módulo de Filtragem}. Ela permite o gerenciamento de filtros, implementados em classes distintas, indexados por um nome e acessados por métodos explicados a seguir.

\begin{enumerate}
	\item \texttt{addFilter(String filterName, IFilter filter)} adiciona um novo filtro \texttt{filter} indexado pelo nome \texttt{filterName}.
	\item \texttt{filter(String filterName, double[] data)} executa o filtro de nome \texttt{filterName} sobre os dados \texttt{data} e retorna um array \texttt{double[]} de mesmo tamanho que \texttt{data} com os dados filtrados.
\end{enumerate}

A interface \texttt{IFilter} define que as classes que implementarem filtros, deverão receber os dados através do método \texttt{execute(double[] data)}, e retorná-los, depois de processados, dentro de um array \texttt{double[]}. Atualmente, duas classes de filtros estão implementadas: \texttt{ButterworthHighpass}, um filtro passa-alta de frequência de corte de 1Hz e \texttt{ButterworthBandPass}, um filtro passa-faixa de frequências de corte de 2hz e 8Hz.

Filtros passa-alta com frequência de corte de 1Hz são geralmente utilizados em aplicações de análise de movimentos usando acelerômetros para remover mudanças na orientação de segmentos do corpo, ajustes de postura e os efeitos da gravidade. Os componentes de frequência mais alta (2-16Hz) refletem as acelerações de segmentos do corpo, tipicamente associadas com movimentos rápidos, marcados por fases de aceleração/desaceleração~\cite{Bonato2004,Patel2009}.

\subsubsection{Gerenciador do Banco de Dados}

O \emph{Gerenciador do Banco de Dados}, implementado na classe \texttt{DatabaseManager} dá acesso ao mecanismo de persistência do arcabouço, que fornece operações de armazenamento e leitura dos dados coletados. A implementação do mecanismo de persistência do arcabouço baseia-se no Sistema de Gerenciamento de Banco de Dados (SGBD) Relacional MySQL\footnote{Disponível em: http://dev.mysql.com/downloads/}. A comunicação entre o \emph{Gerenciador de Dados} e o banco de dados MySQL é feita através do Hibernate\footnote{Disponível em: http://www.hibernate.org/downloads}, um \textit{framework} para mapeamento objeto-relacional escrito na linguagem Java, permitindo consultas em SQL (\textit{Structured Query Language}) ou HQL (\textit{Hibernate Query Language}).

A classe \texttt{DatabaseManager} disponibiliza os seguintes métodos para manipulação dos dados:

\begin{enumerate}
	\item \texttt{getLastReadingSet()} Retorna o identificador \textit{id} do último \texttt{ReadingSet} gravado no banco de dados incrementado de 1. As novas leituras são adicionadas ao \texttt{ReadingSet} de identificador \textit{id} + 1. Isso permite adicionar um grande número de leituras por etapas. Enquanto \texttt{getLastReadingSet()} não for chamado novamente, todas as leituras serão adicionadas ao \texttt{ReadingSet} que for retornado pelo método.
	\item \texttt{addReading(Reading r)} adiciona uma nova leitura \texttt{r}.
	\item \texttt{addReadingSet(ReadingSet set)} adiciona um novo conjunto de leituras \texttt{set}.
	\item \texttt{updateReadingSet(ReadingSet set)} atualiza o conjunto de leituras \texttt{set} passado como atributo com suas novas informações. O identificador do \texttt{set} deve estar inicializado, para que este seja localizado no banco de dados.
	\item \texttt{getReadings(int readingSetId)} retorna uma \texttt{List<Reading>} com as leituras pertencentes ao conjunto de leituras de identificador \texttt{readingSetId}.
\end{enumerate}

\subsection{Analisador de Dados}

O \emph{Analisador de Dados}, implementado pela classe \texttt{DataAnalyzer}, realiza o processamento dos dados e retorna as informações necessárias para a análise. A classe \texttt{IAnalyzer} especifica os métodos que uma classe de análise de dados deve possuir. Uma nova classe deve implementar a interface \texttt{IAnalyzer}. Dois tipos de análise são suportadas atualmente, a análise de tremor e análise de movimentos, realizadas respectivamente pelo \emph{Analisador de Tremor} e \emph{Analisador de Movimentos}. A análise é feita baseada em regras providas ao sistema, utilizadas para definir como classificar as informações.

Os métodos que uma nova classe de análise deve possuir são os seguintes:

\begin{enumerate}
	\item \texttt{addReadingSet(String name, double[] readings)} adiciona o novo conjunto de leituras \texttt{readings} sob o nome \texttt{name}.
	\item \texttt{getReadingSet(String name)} retorna o conjunto de leituras sob o nome \texttt{name}.
	\item \texttt{getResults(String readingSetName)} realiza a análise sobre o conjunto de leituras de nome \texttt{readingSetName} e retorna os resultados em um mapa \texttt{Map<String, Double>} onde a \textit{chave} é o nome de uma variável de retorno da análise, e o \textit{valor} é o valor da variável. A classe de análise deve apresentar todos os seus resultados dentro deste mapa, para avaliação pelo \emph{Gerenciador de Regras}.
\end{enumerate}

Os métodos disponibilizados pela classe \texttt{DataAnalyzer} são:

\begin{enumerate}
	\item \texttt{getDataManager()} retorna a instância do \emph{Gerenciador de Dados}.
	\item \texttt{getRuleManager()} retorna a instância do \emph{Gerenciador de Regras}.
	\item \texttt{addAnalyzer(String name, IAnalyzer analyzer)} adiciona uma nova classe de análise ao \emph{Analisador de Dados}, sob o nome \texttt{name} especificado.
	\item \texttt{getAnalyzer(String name)} retorna o analisador de nome \texttt{name}.
	\item \texttt{fft(double[] data)} executa a Transformada Rápida de Fourier (FFT) sobre os dados passados no array \texttt{data}. Retorna o resultado em um \textit{array} \texttt{double[]}.
\end{enumerate}

\subsubsection{Analisador de Tremor}

A implementação deste módulo é feita pela classe \texttt{TremorAnalyzer}, que processa o sinal do acelerômetro, realizando a análise de espectro para identificar as frequências de tremor predominantes. Pequenos acelerômetros são usados em muitas aplicações clínicas, sendo bastante populares em aplicações para medição de tremor, e são capazes de medir acelerações menores que $0,02g$ ($1g = 9,807 m/s^2$, a aceleração estática da gravidade)~\cite{Elble2005}. O sinal proveniente do acelerômetro de três eixos é composto por coordenadas $(x, y, z)$, que representam a quantificação da força da gravidade sobre o eixo em um determinado momento. Na Figura~\ref{img:eixos}, ilustra-se um esquema de um acelerômetro e seus eixos $x, y$ e $z$, considerando o eixo $z$ perpendicular à força da gravidade $g$.

Para realizar a análise espectral do sinal do acelerômetro, é utilizada a Transformada Rápida de Fourier (\textit{FFT - Fast Fourier Transform}), acessada através do método \texttt{fft(double[] data)}, disponível na classe \texttt{DataAnalyzer}. A FFT transforma um sinal no domínio do tempo para o domínio de frequência. A maioria das análises espectrais é baseada na FFT, e sua simplicidade computacional permite uma implementação eficiente e análise de dados rápida. A análise espectral é um popular método para quantificar tremores, dada a característica oscilatória destes. A ideia é calcular a função de densidade espectral de energia (\textit{Power Spectral Density - PSD}) em frequências diferentes por todo o espectro. A frequência dominante do tremor é evidente no maior pico na densidade espectral de energia~\cite{Riviere199777}.

\begin{figure}[!htb]
     \centering
     \includegraphics[width=.3\textwidth]{eixos.png}
     \caption{Eixos do acelerômetro}
     \label{img:eixos}
\end{figure}

Além dos métodos especificados pela interface \texttt{IAnalyzer}, os seguintes métodos são implementados na classe \texttt{TremorAnalyzer}:

\begin{enumerate}
	\item \texttt{findPeaks(String readingSet, double delta, boolean max)} encontra os picos mínimos ou máximos no sinal contido no conjunto de leituras de nome \texttt{readingSet}. O parâmetro \texttt{delta} é a diferença máxima entre um pico local e geral, usado para encontrar os picos gerais. O valor de \texttt{delta} afeta o número de picos encontrados. O parâmetro \texttt{max} define se o método deve retornar os picos máximos (se \texttt{max} for \texttt{true}) ou máximos e mínimos (se \texttt{max} for \texttt{false}).
	\item \texttt{calculateAmplitude(double[] peaks, double[] times)} retorna a amplitude em centímetros de um sinal de acelerômetro. A precisão do método depende da precisão do acelerômetro.
\end{enumerate}

\subsubsection{Analisador de Movimentos}

O módulo \emph{Analisador de Movimentos} processa os dados obtidos do sensor de movimentos Kinect e medidas angulares obtidas de acelerômetros e giroscópios para calcular a velocidade angular e ângulo de inclinação de segmentos do corpo. O Kinect é um sensor de movimento que funciona baseado em uma câmera e um sensor de profundidade, captando coordenadas 3D de pontos com precisão. Sua eficácia na análise do movimento do corpo humano é comprovada, podendo substituir ferramentas de análise tridimensional quando uma alta acurácia não é necessária~\cite{Tong2012,Pedro2012}. Aplicações vão desde a avaliação do controle postural~\cite{Clark2012372}, à análise de marcha~\cite{gabelfull}.

Esse módulo é capaz de calcular a velocidade linear de movimento de pontos do corpo a partir dos dados do Kinect. Esses dados consistem de coordenadas espaciais $(x, y, z)$, que são as posições do esqueleto capturadas pelo Kinect, cujos valores são dados em unidades métricas. Na Figura~\ref{img:skeletonspace} é mostrado o \textit{Skeleton Space}, um sistema de coordenadas orientado para a direita, que posiciona o Kinect na origem, com o eixo z se estendendo na direção para qual o Kinect aponta. O eixo y positivo se estende para cima e o eixo x positivo se estende para direita.\footnote{Disponível em: http://msdn.microsoft.com/pt-br/library/hh973078.aspx} A Figura~\ref{img:kinect} mostra a representação gráfica das coordenadas da mão esquerda ao acenar, obtidas do Kinect durante aproximadamente 10 segundos.

\begin{figure}[!htb]
     \centering
     \includegraphics[width=.3\textwidth]{IC534689.png}
     \caption{O \textit{Skeleton Space}}
     \label{img:skeletonspace}
\end{figure}

\begin{figure}[!htb]
     \centering
     \includegraphics[width=.8\textwidth]{movimento_kinect.png}
     \caption{Plotagem das coordenadas da mão esquerda}
     \label{img:kinect}
\end{figure}

\subsubsection{Gerenciador de Regras}

O \emph{Gerenciador de Regras} é implementado pela classe \texttt{RuleManager}, e permite especificar regras para classificar os dados provenientes do \emph{Analisador de Dados}. As regras permitem especificar condicionais que definirão uma interpretação para os dados. As regras são especificadas através de arquivos, uma regra por linha, no formato \texttt{variável sinal valor}, onde \texttt{variável} é uma palavra, sem espaços; \texttt{sinal} é um dos operadores \{\texttt{<}, \texttt{<=}, \texttt{==}, \texttt{>=}, \texttt{>}\} e \texttt{valor} é um decimal ou inteiro. No Código~\ref{rulesfile} é mostrado um exemplo de como estruturar o arquivo de regras.

\begin{lstlisting}[caption={Um exemplo de formato do arquivo de regras},label=rulesfile,numbers=none]
amplitude > 0
amplitude < 5
frequency >= 1
frequency < 9
\end{lstlisting}

As regras permitem verificar os resultados providos pelas classes analisadoras. Através das regras, por exemplo, podem ser providos intervalos normais de valores, e os valores obtidos do interação do usuário com os sensores são verificados para checar se são normais ou anormais. No caso de resultados anormais, é necessária uma investigação mais profunda para sua causa.

Os seguintes métodos fazem parte da classe \texttt{RuleManager}:

\begin{enumerate}
	\item \texttt{readRules(String path)} carrega as regras contidas no arquivo provido em \texttt{path}. Este método deve ser chamado antes do método~\ref{checkrulesmethod}, ou a verificação das regras não será efetuada.
	\item \label{checkrulesmethod}\texttt{checkRules(Map<String, Double> data)} verifica se os dados providos em \texttt{data} obedecem às regras definidas. O mapa \texttt{data} é provido por uma das classes de análise de dados.
\end{enumerate}

\section{Utilizando e Estendendo o Arcabouço}

Esta seção demonstra os passos a serem seguidos para utilizar o arcabouço e também estendê-lo. Por utilizar requisições HTTP e JSON para envio e representação dos dados, respectivamente, os métodos para coleta de dados durante o jogo são independentes de linguagem. Entretanto, o arcabouço foi feito em Java, e é necessário utilizar esta linguagem para usar as funções e partes do arcabouço.

\subsection{Lendo e Armazenando os Dados de um Sensor Durante um Jogo}

A coleta dos dados deve ocorrer em uma frequência apropriada para captar atualizações significativas nos valores obtidos dos sensores. Para dados obtidos através de acelerômetros, por exemplo, é recomendável escolher a frequência de amostragem maior que a frequência de ocorrência do evento que se deseja monitorar. Para identificar tremores, a frequência de amostragem deve ser pelo menos de 14 Hz para captar todos tipos de tremores que ocorrem nos membros (ver Tabela~\ref{tab:tremors}). Outros dados, como pulsação, podem ser lidos a uma taxa de amostragem menor, por não possuirem uma alta taxa de atualização.

Para taxas de amostragem altas, recomenda-se que o envio para o \emph{webservice} seja feito de 1000 em 1000 leituras, aproximadamente, ou que todas as leituras sejam armazenadas em arquivo, para serem processadas posteriormente pelo arcabouço. Para taxas de amostragem baixas, as leituras podem ser enviadas ao fim de uma sessão de alguns minutos de jogo. O Código~\ref{coletaenvio} mostra um exemplo em Java de como as leituras devem ser armazenadas e enviadas.

O método \texttt{enviar()} pode deter a execução do código por algum tempo, devido à operação de enviar os dados pela rede. Para que nenhuma leitura do sensor seja perdida, no caso de uma taxa de amostragem alta, o ideal é que as operações dentro de \texttt{enviar()} sejam executadas em uma \textit{thread} diferente.

O objeto JSON \texttt{leitura}, mostrado no Código~\ref{objectjson} que representa uma leitura do sensor deve conter os atributos \textit{id}, \textit{idUsuario}, \textit{x}, \textit{y}, \textit{z} e \textit{timestamp}.

\begin{itemize}
	\item \textit{id} é o identificador da tabela do banco de dados, e pode ser enviado com valor 0, pois o objeto receberá o verdadeiro identificador quando for processado pelo \textit{Gerenciados de Dados}.
	\item \textit{idUsuario} é o identificador do usuário dentro da tabela de usuários no banco de dados, criada para uso futuro. O atributo \textit{timestamp} é a data e hora da leitura, convertida para um \texttt{long} que representa o número de milissegundos desde 1 de Janeiro de 1970 até a data e hora de leitura.
	\item \textit{x}, \textit{y} e \textit{z} são os valores decimais de uma leitura do sensor. Para acelerômetros, representam a aceleração nos eixos x, y e z, respectivamente. Para o Kinect, a posição da pessoa no \textit{Skeleton Space}. Para outros sensores cuja leitura possui um número de atributos menor que 3, apenas os atributos que possuem valor devem ser preenchidos e os atributos restantes terão valor 0. Para sensores cuja leitura retorna mais de 3 atributos, deve-se armazená-los em arquivo e utilizar os métodos apropriados do arcabouço.
\end{itemize}

\begin{lstlisting}[caption={O objeto JSON \textit{leitura}},label=objectjson,numbers=none]
{"id":0,
"idUsuario":1,
"x":2.9097333,
"y":6.770132,
"z":2.0355952,
"timestamp":1336134935706}
\end{lstlisting}

\begin{lstlisting}[caption={Coleta e envio das leituras},label=coletaenvio,numbers=none]
int contador = 0;
final int MAX = 1000;
List<Leitura> dados = new ArrayList<Leitura>();

private void adicionaDado(Leitura dado){
    List<Leitura> copia;
    if (contador < MAX) {
        dados.add(dado);
        contador++;
    } else {
        copia = dados;
        dados.clear();
        enviar(copia);
    }
}
\end{lstlisting}

O envio de dados através de arquivos é mais flexível, pois é possível estender o \texttt{FileManager} para permitir a leitura de um formato de dados específico gravado em arquivo e sua posterior conversão em uma estrutura de dados a ser utilizada no arcabouço. Mais detalhes sobre a extensão do \texttt{FileManager} são apresentados na Seção~\ref{sec:extendingfile}.

\subsection{Estendendo o Arcabouço} \label{sec:extending}

A estrutura do arcabouço permite a extensão de praticamente qualquer uma de suas partes. Esta seção mostra os passos a serem seguidos para estender as partes do arcabouço. As partes são extensíveis a partir do uso de interfaces, que reduz o acoplamento do código.

\subsection{\textit{Classes de Análise de Dados}}

Cada classe de análise de dados estende a interface \texttt{IAnalyzer}, que agrega os métodos que definem o comportamento comum de todos os módulos analisadores de dados. Uma nova classe de análise deve implementar a interface \texttt{IAnalyzer} e prover a implementação concreta de seus métodos, definindo seu código específico de análise.

A classe abstrata \texttt{AnalyzerImpl} possui a implementação dos métodos \texttt{addReadingSet(String name, double[] data)} e \texttt{getReadingSet(String name)}, que é comum a todas as classes de análise. A nova classe de análise pode estender diretamente a classe \texttt{AnalyzerImpl} e implementar somente o método \texttt{getResults(String name)}, ou, se necessitar  implementar um comportamento diferente para os dois métodos \texttt{addReadingSet} e \texttt{getReadingSet}, a classe deve implementar diretamente a interface \texttt{IAnalyzer}. O Código~\ref{classeanalise} mostra um exemplo de implementação de uma nova classe de análise de dados.

\begin{lstlisting}[caption={Um Exemplo de Classe de Análise de Dados},label=classeanalise,numbers=none]
public class GaitAnalyzer implements IAnalyzer {
   private Map<String, double[]> readings = 
      new HashMap<String, double[]>();
   private DataAnalyzer dataAnalyzer;

   public AnalyzerImpl(DataAnalyzer dataAnalyzer) {
      this.dataAnalyzer = dataAnalyzer;
   }

   @Override
   public void addReadingSet(String name, double[] data) {
      readings.put(name, data);
   }

   @Override
   public double[] getReadingSet(String name) {
      return readings.get(name);
   }

   @Override
   public Map<String, Double> getResults(String readingSetName) {
      // Definir código específico de análise de dados
   }
}
\end{lstlisting}

\subsection{\textit{Filtros}}

Novos filtros de dados podem ser adicionados, implementando a interface \texttt{IFilter}. As novas classes de filtros devem implementar a sua forma de filtragem dentro do método \texttt{execute(double[] data)}, recebendo os dados através do parâmetro \texttt{data} do método. O Código~\ref{classefiltro}

\begin{lstlisting}[caption={Um Exemplo de Classe de Filtragem de Dados},label=classefiltro,numbers=none]
public class SimpleLowPassFilter implements IFilter {
   @Override
   public double[] execute(double[] data) {
      // Realizar a filtragem
   }
}
\end{lstlisting}

\subsection{\textit{Gerenciador de Arquivos}} \label{sec:extendingfile}

A transferência de dados para o arcabouço através de arquivos permite uma maior liberdade para representação dos dados. A transferência de dados pelo \emph{webservice} cobre as necessidades para a maioria dos sensores, entretanto, para formatos de dados especiais, é necessário recorrer à transferência por arquivos. A extensão do \emph{Gerenciador de Arquivos} permite adicionar novos métodos para leitura de dados e ainda assim utilizar toda a estrutura do arcabouço. A classe \texttt{DataManager} pode ser estendida, para criar um novo \emph{Gerenciador de Arquivos}. O Código~\ref{gerarquivosclasse} mostra um exemplo de como estender o \emph{Gerenciador de Arquivos} (linha 1) e como utilizar o novo gerenciador \texttt{GaitDataFileManager} (linha 12).

\begin{lstlisting}[caption={Um Exemplo de Extensão do Gerenciador de Arquivos},label=gerarquivosclasse,numbers=left]
public class GaitDataFileManager extends FileManager {
   
   public List<Stride> getGaitData(String path) {
      // Realizar a filtragem
   }
}

public class UsingTheFramework {

   public static void main(String[] args) {
      DatabaseManager dbMan = new DatabaseManager();
      FileManager fileMan = new GaitDataFileManager();
      WriterModule writerMod = new WriterModule();
      FilterModule filterMod = new FilterModule();

      DataManager dataMan = new DataManager(dbMan, fileMan, writerMod, filterMod);
   }
}
\end{lstlisting}

\subsection{\textit{Classes de Escrita de Dados}}

A extensão das classes de escrita de dados é feita através da implementação da interface \texttt{IWriter} ou extensão da classe \texttt{WriterImpl}, sendo o primeiro caso indicado quando se quer os métodos \texttt{writeLine}, \texttt{formatLine} e \texttt{save} com comportamentos diferentes dos métodos implementados pela classe \texttt{WriterImpl}. Um exemplo de criação de uma nova classe de escrita de dados encontra-se no Código~\ref{classeescrita}.

\begin{lstlisting}[caption={Um Exemplo de Classe de Escrita de Dados},label=classeescrita,numbers=none]
public class DashSeparatedValuesWriter extends WriterImpl {

	public DashSeparatedValuesWriter(String path, String... titles) throws IOException {
		super(path, titles);
	}

	@Override
	public String formatLine(Object... items) {
		return addSeparator("-", items);
	}
}
\end{lstlisting}

\section{Conclusão}

Este capítulo apresentou a estrutura geral do arcabouço, detalhando suas partes e operações. Foram apresentadas as operações disponibilizadas pelo \emph{webservice} e as classes, e seus respectivos métodos, que fazem parte do arcabouço. Por fim, foram descritas a forma de utilização do arcabouço na construção de um jogo e a forma de extensão do arcabouço, para adicionar novas funcionalidades.